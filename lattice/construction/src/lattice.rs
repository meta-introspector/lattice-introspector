use std::collections::HashMap;
use lattice_types::{LatticePoint, LatticePointKind, LatticeHandle, LatticeAccess};
use once_cell::sync::Lazy;
use lattice_macros::LatticePointDerive; // Add this line

/// The univalent lattice that models the entire universe of universes.
/// It contains a collection of LatticePoints, including its own meta-description.
#[derive(Debug, Clone, PartialEq, Eq, LatticePointDerive)] // Apply the macro
pub struct Lattice {
    pub points: HashMap<String, LatticePoint>,
    pub meta_point_id: String, // The ID of the LatticePoint that describes this Lattice instance
}

// Global static instance of the Lattice
static GLOBAL_LATTICE: Lazy<Lattice> = Lazy::new(|| {
    let mut lattice = Lattice {
        points: HashMap::new(),
        meta_point_id: String::new(), // Will be set after the meta_point is created
    };

    // Placeholder for creating the meta_point for the Lattice itself.
    // This will eventually involve compile-time introspection.
    let meta_point = LatticePoint {
        id: "lattice_meta".to_string(),
        kind: LatticePointKind::LatticeMeta,
        metadata: HashMap::new(), // This will be populated with Lattice's own structure
        relationships: Vec::new(),
        hero_status: None,
    };

    lattice.points.insert(meta_point.id.clone(), meta_point);
    lattice.meta_point_id = "lattice_meta".to_string();

    // Call the generated registration function here
    // This function will be generated by build.rs and included in lib.rs
    // It will add all derived LatticePoints to this lattice instance.
    crate::register_all_lattice_points(&mut lattice);

    lattice
});

impl Lattice {
    // Private new function, as we'll use the global instance
    fn new() -> Self {
        // This will be called by Lazy::new, so the logic is above in the static initializer
        unreachable!("Lattice::new() should not be called directly. Use get_global_lattice().");
    }
}

impl LatticeAccess for Lattice {
    // Method to add a new LatticePoint to the lattice
    fn add_point(&mut self, point: LatticePoint) -> LatticeHandle {
        eprintln!("DEBUG: Adding point: ID = {}, Kind = {:?}", point.id, point.kind);
        let handle = LatticeHandle(point.id.clone());
        self.points.insert(point.id.clone(), point);
        handle
    }

    // Method to retrieve a LatticePoint by its ID
    fn get_point(&self, handle: &LatticeHandle) -> Option<&LatticePoint> {
        self.points.get(&handle.0)
    }
}

/// Returns a reference to the globally accessible Lattice instance.
pub fn get_global_lattice() -> &'static Lattice {
    &GLOBAL_LATTICE
}
